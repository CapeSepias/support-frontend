@import '~stylesheets/gu-sass/gu-sass';

@mixin block-colours($border, $bg: null, $text: null) {
  @if($text){
    color: $text;
  }
  @if($bg){
    &, .component-product-page-content-block-bg {
      background-color: $bg;
    }
  }
  &, .component-product-page-content-block-bg,
  & .component-left-margin-section__content,
  & .component-product-page-features .component-product-page-features__item {
    border-color: $border;
  }
  & .component-product-page-content-block-divider__line {
    @include multiline(4, $border);
  }
  /*
  All our ContentBlocks have the behaviour of rendering 
  with a border between them if there's two with the same 
  background colour in a row.

  These selectors attempt to enforce this by applying the 
  border to .selector + .selector (adjacent sibling) 
  
  The second selector applies the rule to the first child 
  of an element wrapped in an extra div if it matches the 
  classname (because React makes you do that sometimes)

  I hope this explains it:

  +----------------+
  | blue block     |
  +----------------+
  +----------------+
  | wrapping div   |
  |+--------------+|
  || another blue ||
  || block        ||
  |+--------------+|
  +----------------+

  */
  & + &,
  & + div > &:first-child  {
    .component-left-margin-section__content {
      border-top: 1px solid $border;
    }
  }    
}

.component-product-page-content-block .component-left-margin-section__content {
  max-width: 100%;
  position: relative;
  @include mq($from: tablet) {
    border-left: 1px solid gu-colour(garnett-neutral-4);
  }
}

.component-product-page-content-block--overflow-hidden .component-left-margin-section__content {
  overflow: hidden;
}

.component-product-page-content-block--white {
  @include block-colours(
    $border: gu-colour(garnett-neutral-4)
  );
}

.component-product-page-content-block--grey {
  @include block-colours(
    $border: transparent,
    $bg: gu-colour(garnett-neutral-3),
  );
}

.component-product-page-content-block--feature {
  @include block-colours(
    $border: gu-colour(header-border),
    $bg: gu-colour(header-dark),
    $text: gu-colour(garnett-neutral-5),
  );
}

.component-product-page-content-block--feature-secondary {
  @include block-colours(
    $border: gu-colour(header-border),
    $bg: gu-colour(news-garnett-highlight),
    $text: gu-colour(garnett-neutral-1)
  );
}

.component-product-page-content-block--dark {
  @include block-colours(
    $border: gu-colour(garnett-neutral-5),
    $text: gu-colour(garnett-neutral-5),
    $bg: gu-colour(garnett-neutral-7),
  );
}

.component-product-page-content-block__content {
  max-width: gu-span(12);
  padding: ($gu-v-spacing/2) ($gu-h-spacing / 2) 0;
}

.component-product-page-content-block-outset {
  margin-left: ($gu-h-spacing / 2 * -1);
  margin-right: ($gu-h-spacing / 2 * -1);
}

.component-product-page-content-block-divider {
  height: 20px;
  margin-bottom: ($gu-v-spacing*.33);
}

.component-product-page-content-block-divider__line {
  position: absolute;
  left: 0;
  right: 0;
  border: 0;
  margin: 0;
}

// ----- Vertical rhythm ------ //

.component-product-page-content-block {
  .component-product-page-text-block, 
  .component-product-page-plan-form,
  .component-product-page-info-chip {
    margin-bottom: ($gu-v-spacing*2)
  }
  .component-product-page-text-block--heading-only + .component-product-page-content-block-divider {
    margin-top: ($gu-v-spacing*-1)
  }
  .component-product-page-content-block__content > .component-product-page-content-block-divider:first-child {
    margin-top: ($gu-v-spacing*-.5) - 1px;
    /*
    cancel out padding if this is the first child then
    overlap under the top border to avoid the first multiline
    merging with it and looking like a 2px border 
    */
  }
}


// ----- Images ------ //

.component-product-page-content-block__image {
  max-width: gu-span(6);
  @include mq($from: tablet) {
    position: absolute;
    left: gu-span(7) + $gu-h-spacing;
  }
  @include mq($from: desktop) {
    left: gu-span(8) + $gu-h-spacing;
  }
  bottom: ($gu-v-spacing*2)*-1;
  .component-grid-image {
    display: block;
    width: 100%;
  }
  /*
  If you are implementing an image in a page and you want
  it to look just a teeny tiny bit bigger or smaller or plain move it, 
  try to avoid overriding `left` to do fine positioning and 
  instead use transforms and max-width.

  `left` here is built to put images to the right of the max grid width. 
  This width might change in the future and ideally tweaking these global 
  values should not break any images on any page.

  If your image is not grid aligned feel free to override these values
  but also consider if using this image prop is the best approach. You can
  put your image as a normal child of `ContentBlock`
  */
}
